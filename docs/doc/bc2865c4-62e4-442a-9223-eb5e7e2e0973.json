{
    "summary": "This code initializes necessary components, defines conversion functions and calculates target poses, handles states and debug settings. It checks for motion commands and executes robot movement accordingly, with a 'End!' statement to end the program.",
    "details": [
        {
            "comment": "This code imports necessary libraries and sets up the base, Realsense camera, and PID controller. It defines functions for converting yaw to a vector and obtaining the robot's pose. The TracerBase is enabled for CAN communication and the pipeline for the camera is started with only the pose stream enabled for higher FPS. A class for a PIDController is also defined.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/waypoint_control.py\":0-39",
            "content": "import pyagxrobots\nimport time\nimport IPython\ne = IPython.embed\nimport pyrealsense2 as rs\nfrom pyquaternion import Quaternion\nimport numpy as np\nfrom simple_pid import PID\nimport argparse\nnp.set_printoptions(precision=3, suppress=True)\nargparser = argparse.ArgumentParser()\nargparser.add_argument('--debug', action='store_true')\nargs = argparser.parse_args()\n# setup base\ntracer = pyagxrobots.pysdkugv.TracerBase()\ntracer.EnableCAN()\n# setup realsense\npipeline = rs.pipeline()\ncfg = rs.config()\n# if only pose stream is enabled, fps is higher (202 vs 30)\ncfg.enable_stream(rs.stream.pose)\npipeline.start(cfg)\ndef yaw_to_vector(yaw):\n    return np.array([np.cos(yaw), np.sin(yaw)])\ndef get_pose():\n    frames = pipeline.wait_for_frames()\n    pose_frame = frames.get_pose_frame()\n    pose = pose_frame.get_pose_data()\n    yaw = -1 * Quaternion(pose.rotation.w, pose.rotation.x, pose.rotation.y, pose.rotation.z).yaw_pitch_roll[0]\n    pose_np = np.array([pose.translation.z, pose.translation.x, yaw])\n    return pose_np\nclass PIDController:"
        },
        {
            "comment": "This code initializes a PID controller and provides a function to normalize angles. It also calculates target poses by incrementally moving along a path within a specified range of angle.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/waypoint_control.py\":40-72",
            "content": "    def __init__(self, kp, ki, kd):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.prev_error = 0\n        self.integral = 0\n    def compute(self, error, dt=1):\n        self.integral += error * dt\n        derivative = (error - self.prev_error) / dt\n        output = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.prev_error = error\n        return output\ndef normalize_angle(angle):\n    while angle > np.pi:\n        angle -= 2 * np.pi\n    while angle < -np.pi:\n        angle += 2 * np.pi\n    return angle\n# init global coords\nr = 0.2\nstart_pose = get_pose()\ndelta_target_pose_l = [\n    np.array([\n        r * np.sin(theta), \n        -(r - r * np.cos(theta)), \n        -theta]) for theta in np.linspace(0, np.pi / 2, int((np.pi / 2) // (0.01 / r)))\n]\ntarget_pose_l = []\nfor delta_target_pose in delta_target_pose_l:\n    transformed_delta_target_pose_x = delta_target_pose[0] * np.cos(start_pose[2]) - delta_target_pose[1] * np.sin(start_pose[2])\n    transformed_delta_targe"
        },
        {
            "comment": "This code calculates a transformed target pose based on the current start pose and delta target pose. It then stores these poses in the list target_pose_l. The code then loops until it reaches the target pose, updating the current pose and checking if the distance to the target position and orientation are within specified thresholds. If so, the loop breaks. The code also defines constants for velocity limits and threshold values.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/waypoint_control.py\":72-103",
            "content": "t_pose_y = delta_target_pose[0] * np.sin(start_pose[2]) + delta_target_pose[1] * np.cos(start_pose[2])\n    transformed_target_pose = np.array([\n        start_pose[0] + transformed_delta_target_pose_x,\n        start_pose[1] + transformed_delta_target_pose_y,\n        normalize_angle(start_pose[2] + delta_target_pose[2])\n    ])\n    target_pose_l.append(transformed_target_pose)\nMAX_LINEAR_VEL = 0.1\nMIN_LINEAR_VEL = -0.1\nMAX_ANGULAR_VEL = 0.3\nMIN_ANGULAR_VEL = -0.3\nPOS_THRESHOLD = 0.05\nORN_THRESHOLD = 0.1\nDT = 0.1\nprint(target_pose_l)\nfor target_pose in target_pose_l:\n    target_pos = target_pose[:2]\n    target_orn = target_pose[2]\n    while True:\n        curr_pose = get_pose()\n        curr_pos, curr_orn = curr_pose[:2], curr_pose[2]\n        distance_to_target = np.linalg.norm(target_pos - curr_pos) \n        error_orn = normalize_angle(target_orn - curr_orn)\n        if distance_to_target < POS_THRESHOLD and abs(error_orn) < ORN_THRESHOLD:\n            break\n        target_heading = np.arctan2(target_pos[1] - curr_pos[1], target_pos[0] - curr_pos[0])"
        },
        {
            "comment": "This code calculates the robot's linear and angular velocities based on its current position, target position, and current orientation. It then applies these velocities to move the robot towards the target while accounting for distance and heading errors. The code also prints out various information about the robot's state and, if in debug mode, sets the tracer's motion commands to zero.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/waypoint_control.py\":104-134",
            "content": "        error_heading = normalize_angle(target_heading - curr_orn)\n        if distance_to_target < POS_THRESHOLD:\n            is_forward = 1\n            v = 0\n            w = error_orn / DT\n        else:\n            is_forward = np.sign(np.dot(\n                yaw_to_vector(target_heading), yaw_to_vector(curr_orn)))\n            v = distance_to_target * is_forward / DT\n            w = error_heading * is_forward / DT\n        v = np.clip(v, MIN_LINEAR_VEL, MAX_LINEAR_VEL)\n        w = np.clip(w, MIN_ANGULAR_VEL, MAX_ANGULAR_VEL)\n        print(f'''\n            curr_pose: {curr_pose},\n            target_pose: {target_pose},\n            is_forward: {is_forward},\n            action: {np.array([v, w])},\n            error_heading: {error_heading:0.3f},\n            error_orn: {error_orn:0.3f},\n            distance: {distance_to_target:0.3f}\n            --------------------------\n        ''')\n        if args.debug:\n            tracer.SetMotionCommand(\n                linear_vel=0,\n                angular_vel=0.1\n            )"
        },
        {
            "comment": "This code checks if the motion command has been received. If it has, it sets the linear and angular velocity for the robot's movement and then waits 0.05 seconds before executing the movement. If no motion command is detected, it simply sleeps for 1 second. The program ends with a 'End!' print statement.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/waypoint_control.py\":135-146",
            "content": "            time.sleep(1)\n        else:\n            # set motion command\n            tracer.SetMotionCommand(\n                linear_vel=v,\n                angular_vel=w\n            )\n            time.sleep(0.05)\nprint('End!')"
        }
    ]
}