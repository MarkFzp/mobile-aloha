{
    "summary": "The Python module simplifies Dynamixel robot communication with client class and readers, initializes motors, controls robots via functions, and handles errors and synchronization. The code creates classes for reading motor position and velocity, connects to clients, measures operation time, and prints data.",
    "details": [
        {
            "comment": "This code is a Python module for communication with Dynamixel robots using the DynamixelSDK. It defines addresses and data byte lengths for various robot parameters, as well as scaling factors for position, velocity, and current readings. The dynamixel_cleanup_handler function ensures proper disconnection of Dynamixel clients when necessary.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":0-37",
            "content": "\"\"\"Communication using the DynamixelSDK.\"\"\"\n##This is based off of the dynamixel SDK\nimport atexit\nimport logging\nimport time\nfrom typing import Optional, Sequence, Union, Tuple\nimport numpy as np\nPROTOCOL_VERSION = 2.0\n# The following addresses assume XH motors.\nADDR_TORQUE_ENABLE = 64\nADDR_GOAL_POSITION = 116\nADDR_PRESENT_POSITION = 132\nADDR_PRESENT_VELOCITY = 128\nADDR_PRESENT_CURRENT = 126\nADDR_PRESENT_POS_VEL_CUR = 126\n# Data Byte Length\nLEN_PRESENT_POSITION = 4\nLEN_PRESENT_VELOCITY = 4\nLEN_PRESENT_CURRENT = 2\nLEN_PRESENT_POS_VEL_CUR = 10\nLEN_GOAL_POSITION = 4\nDEFAULT_POS_SCALE = 2.0 * np.pi / 4096  # 0.088 degrees\n# See http://emanual.robotis.com/docs/en/dxl/x/xh430-v210/#goal-velocity\nDEFAULT_VEL_SCALE = 0.229 * 2.0 * np.pi / 60.0  # 0.229 rpm\nDEFAULT_CUR_SCALE = 1.34\ndef dynamixel_cleanup_handler():\n    \"\"\"Cleanup function to ensure Dynamixels are disconnected properly.\"\"\"\n    open_clients = list(DynamixelClient.OPEN_CLIENTS)\n    for open_client in open_clients:\n        if open_client.port_handler.is_using:\n            logging.warning('Forcing client to close.')"
        },
        {
            "comment": "The code defines a DynamixelClient class for communicating with Dynamixel motors, using Protocol 2. It has methods to convert signed to unsigned and vice versa. The OPEN_CLIENTS variable keeps track of currently open clients. The constructor takes motor_ids, port, baudrate, lazy_connect, and pos_scale as parameters.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":38-73",
            "content": "        open_client.port_handler.is_using = False\n        open_client.disconnect()\ndef signed_to_unsigned(value: int, size: int) -> int:\n    \"\"\"Converts the given value to its unsigned representation.\"\"\"\n    if value < 0:\n        bit_size = 8 * size\n        max_value = (1 << bit_size) - 1\n        value = max_value + value\n    return value\ndef unsigned_to_signed(value: int, size: int) -> int:\n    \"\"\"Converts the given value from its unsigned representation.\"\"\"\n    bit_size = 8 * size\n    if (value & (1 << (bit_size - 1))) != 0:\n        value = -((1 << bit_size) - value)\n    return value\nclass DynamixelClient:\n    \"\"\"Client for communicating with Dynamixel motors.\n    NOTE: This only supports Protocol 2.\n    \"\"\"\n    # The currently open clients.\n    OPEN_CLIENTS = set()\n    def __init__(self,\n                 motor_ids: Sequence[int],\n                 port: str = '/dev/ttyUSB0',\n                 baudrate: int = 1000000,\n                 lazy_connect: bool = False,\n                 pos_scale: Optional[float] = None,"
        },
        {
            "comment": "The code defines a function that initializes a new client for communication with Dynamixel devices. It accepts arguments such as motor IDs, device port, baudrate, and scaling factors for positions, velocities, and currents. The \"lazy_connect\" argument enables automatic connection if not already connected.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":74-92",
            "content": "                 vel_scale: Optional[float] = None,\n                 cur_scale: Optional[float] = None):\n        \"\"\"Initializes a new client.\n        Args:\n            motor_ids: All motor IDs being used by the client.\n            port: The Dynamixel device to talk to. e.g.\n                - Linux: /dev/ttyUSB0\n                - Mac: /dev/tty.usbserial-*\n                - Windows: COM1\n            baudrate: The Dynamixel baudrate to communicate with.\n            lazy_connect: If True, automatically connects when calling a method\n                that requires a connection, if not already connected.\n            pos_scale: The scaling factor for the positions. This is\n                motor-dependent. If not provided, uses the default scale.\n            vel_scale: The scaling factor for the velocities. This is\n                motor-dependent. If not provided uses the default scale.\n            cur_scale: The scaling factor for the currents. This is\n                motor-dependent. If not provided uses the default scale."
        },
        {
            "comment": "This code initializes and configures the dynamixel_sdk module, sets port, baudrate, and lazy_connect parameters, creates port and packet handlers, and instantiates DynamixelPosVelCurReader and DynamixelPosReader objects for motor position, velocity, and current reading.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":93-117",
            "content": "        \"\"\"\n        import dynamixel_sdk\n        self.dxl = dynamixel_sdk\n        self.motor_ids = list(motor_ids)\n        self.port_name = port\n        self.baudrate = baudrate\n        self.lazy_connect = lazy_connect\n        self.port_handler = self.dxl.PortHandler(port)\n        self.packet_handler = self.dxl.PacketHandler(PROTOCOL_VERSION)\n        self._pos_vel_cur_reader = DynamixelPosVelCurReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,\n        )\n        self._pos_reader = DynamixelPosReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,"
        },
        {
            "comment": "The code initializes the Dynamixel motors and sets up readers for position, velocity, and current. It also creates a dictionary to manage synchronization writers, keeps track of connections with `OPEN_CLIENTS` set, and provides a connect function to establish communication with Dynamixel motors.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":118-145",
            "content": "        )\n        self._vel_reader = DynamixelVelReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,\n        )\n        self._cur_reader = DynamixelCurReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,\n        )\n        self._sync_writers = {}\n        self.OPEN_CLIENTS.add(self)\n    @property\n    def is_connected(self) -> bool:\n        return self.port_handler.is_open\n    def connect(self):\n        \"\"\"Connects to the Dynamixel motors.\n        NOTE: This should be called after all DynamixelClients on the same\n            process are created."
        },
        {
            "comment": "This code snippet is part of a Dynamixel client implementation. It ensures the client is not already connected before attempting to connect, and then opens the specified port (checking for any errors). The baud rate is set according to the specified value, also checking for any errors. The code also includes a comment about enabling all motors, but it is commented out, suggesting this may be a future feature. The disconnect function checks if the client is connected before attempting to disconnect.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":146-170",
            "content": "        \"\"\"\n        assert not self.is_connected, 'Client is already connected.'\n        if self.port_handler.openPort():\n            logging.info('Succeeded to open port: %s', self.port_name)\n        else:\n            raise OSError(\n                ('Failed to open port at {} (Check that the device is powered '\n                 'on and connected to your computer).').format(self.port_name))\n        if self.port_handler.setBaudRate(self.baudrate):\n            logging.info('Succeeded to set baudrate to %d', self.baudrate)\n        else:\n            raise OSError(\n                ('Failed to set the baudrate to {} (Ensure that the device was '\n                 'configured for this baudrate).').format(self.baudrate))\n        # Start with all motors enabled.  NO, I want to set settings before enabled\n        #self.set_torque_enabled(self.motor_ids, True)\n    def disconnect(self):\n        \"\"\"Disconnects from the Dynamixel device.\"\"\"\n        if not self.is_connected:\n            return\n        if self.port_handler.is_using:"
        },
        {
            "comment": "Ensures motors are disabled at the end, and removes instance from open clients when port is closed.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":171-195",
            "content": "            logging.error('Port handler in use; cannot disconnect.')\n            return\n        # Ensure motors are disabled at the end.\n        self.set_torque_enabled(self.motor_ids, False, retries=0)\n        self.port_handler.closePort()\n        if self in self.OPEN_CLIENTS:\n            self.OPEN_CLIENTS.remove(self)\n    def set_torque_enabled(self,\n                           motor_ids: Sequence[int],\n                           enabled: bool,\n                           retries: int = -1,\n                           retry_interval: float = 0.25):\n        \"\"\"Sets whether torque is enabled for the motors.\n        Args:\n            motor_ids: The motor IDs to configure.\n            enabled: Whether to engage or disengage the motors.\n            retries: The number of times to retry. If this is <0, will retry\n                forever.\n            retry_interval: The number of seconds to wait between retries.\n        \"\"\"\n        remaining_ids = list(motor_ids)\n        while remaining_ids:\n            remaining_ids = self.write_byte("
        },
        {
            "comment": "This code snippet defines a class for controlling Dynamixel robots. It includes functions to set torque, read positions, velocities, and currents for all connected actuators. The function `write_pos_vel_cur` sets the torque of all connected actuators. If not all IDs are enabled, it logs an error message. Retries with a sleep interval if necessary until all IDs are enabled or retries run out. Functions `read_pos_vel_cur`, `read_pos`, `read_vel`, and `read_cur` return the current positions, velocities, and currents for all connected actuators respectively.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":196-220",
            "content": "                remaining_ids,\n                int(enabled),\n                ADDR_TORQUE_ENABLE,\n            )\n            if remaining_ids:\n                logging.error('Could not set torque %s for IDs: %s',\n                              'enabled' if enabled else 'disabled',\n                              str(remaining_ids))\n            if retries == 0:\n                break\n            time.sleep(retry_interval)\n            retries -= 1\n    def read_pos_vel_cur(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._pos_vel_cur_reader.read()\n    def read_pos(self) -> np.ndarray:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._pos_reader.read()\n    def read_vel(self) -> np.ndarray:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._vel_reader.read()\n    def read_cur(self) -> np.ndarray:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._cur_reader.read()"
        },
        {
            "comment": "The code defines two methods: \"write_desired_pos\" and \"write_byte\". The former writes the given desired positions to the Dynamixel motors, ensuring that the number of motor IDs matches the number of positions. It also converts the positions to the Dynamixel position space using the _pos_vel_cur_reader's pos_scale. The latter method writes a value to the motors at a specified address in the control table. Both methods require motor IDs, a value or positions (in radians), and an address.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":222-253",
            "content": "    def write_desired_pos(self, motor_ids: Sequence[int],\n                          positions: np.ndarray):\n        \"\"\"Writes the given desired positions.\n        Args:\n            motor_ids: The motor IDs to write to.\n            positions: The joint angles in radians to write.\n        \"\"\"\n        assert len(motor_ids) == len(positions)\n        # Convert to Dynamixel position space.\n        positions = positions / self._pos_vel_cur_reader.pos_scale\n        self.sync_write(motor_ids, positions, ADDR_GOAL_POSITION,\n                        LEN_GOAL_POSITION)\n    def write_byte(\n            self,\n            motor_ids: Sequence[int],\n            value: int,\n            address: int,\n    ) -> Sequence[int]:\n        \"\"\"Writes a value to the motors.\n        Args:\n            motor_ids: The motor IDs to write to.\n            value: The value to write to the control table.\n            address: The control table address to write to.\n        Returns:\n            A list of IDs that were unsuccessful.\n        \"\"\"\n        self.check_connected()"
        },
        {
            "comment": "This code defines a function that writes values to a group of motors and returns a list of motor IDs that encountered errors during the process. It first checks if the robot is connected, then initializes an empty list for storing errored IDs. For each motor ID in the given sequence, it attempts to write the specified value to its corresponding address using the packet_handler's `write1ByteTxRx` method. If the attempt fails (indicated by a non-success result from the `handle_packet_result` function), the ID is appended to the errored ID list. Finally, it returns this list of errored motor IDs.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":254-278",
            "content": "        errored_ids = []\n        for motor_id in motor_ids:\n            comm_result, dxl_error = self.packet_handler.write1ByteTxRx(\n                self.port_handler, motor_id, address, value)\n            success = self.handle_packet_result(\n                comm_result, dxl_error, motor_id, context='write_byte')\n            if not success:\n                errored_ids.append(motor_id)\n        return errored_ids\n    def sync_write(self, motor_ids: Sequence[int],\n                   values: Sequence[Union[int, float]], address: int,\n                   size: int):\n        \"\"\"Writes values to a group of motors.\n        Args:\n            motor_ids: The motor IDs to write to.\n            values: The values to write.\n            address: The control table address to write to.\n            size: The size of the control table value being written to.\n        \"\"\"\n        self.check_connected()\n        key = (address, size)\n        if key not in self._sync_writers:\n            self._sync_writers[key] = self.dxl.GroupSyncWrite("
        },
        {
            "comment": "Code snippet initializes a sync writer, iterates through motor IDs and desired positions, converts values to byte format, checks for successful addition of parameters, logs any failed writes, sends the packet, clears the parameters, and checks if the robot is connected.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":279-306",
            "content": "                self.port_handler, self.packet_handler, address, size)\n        sync_writer = self._sync_writers[key]\n        errored_ids = []\n        for motor_id, desired_pos in zip(motor_ids, values):\n            value = signed_to_unsigned(int(desired_pos), size=size)\n            value = value.to_bytes(size, byteorder='little')\n            success = sync_writer.addParam(motor_id, value)\n            if not success:\n                errored_ids.append(motor_id)\n        if errored_ids:\n            logging.error('Sync write failed for: %s', str(errored_ids))\n        comm_result = sync_writer.txPacket()\n        self.handle_packet_result(comm_result, context='sync_write')\n        sync_writer.clearParam()\n    def check_connected(self):\n        \"\"\"Ensures the robot is connected.\"\"\"\n        if self.lazy_connect and not self.is_connected:\n            self.connect()\n        if not self.is_connected:\n            raise OSError('Must call connect() first.')\n    def handle_packet_result(self,\n                             comm_result: int,"
        },
        {
            "comment": "This function handles communication results and checks for errors. It takes three optional parameters: dxl_error, dxl_id, and context. If an error is found in the communication result or if dxl_error is not None, it generates an error message with optional information about motor ID and context. The error message is logged using logging.error() and returns False to indicate failure. Otherwise, it returns True for success.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":307-328",
            "content": "                             dxl_error: Optional[int] = None,\n                             dxl_id: Optional[int] = None,\n                             context: Optional[str] = None):\n        \"\"\"Handles the result from a communication request.\"\"\"\n        error_message = None\n        if comm_result != self.dxl.COMM_SUCCESS:\n            error_message = self.packet_handler.getTxRxResult(comm_result)\n        elif dxl_error is not None:\n            error_message = self.packet_handler.getRxPacketError(dxl_error)\n        if error_message:\n            if dxl_id is not None:\n                error_message = '[Motor ID: {}] {}'.format(\n                    dxl_id, error_message)\n            if context is not None:\n                error_message = '> {}: {}'.format(context, error_message)\n            logging.error(error_message)\n            return False\n        return True\n    def convert_to_unsigned(self, value: int, size: int) -> int:\n        \"\"\"Converts the given value to its unsigned representation.\"\"\"\n        if value < 0:"
        },
        {
            "comment": "This code defines a DynamixelReader class that reads data from Dynamixel motors. It initializes a GroupBulkRead operation with the client's port and packet handlers. The __init__ method takes motor IDs, address, and size as parameters. A __del__ method is also defined to automatically disconnect on destruction. The code enables use as a context manager with __enter__ and __exit__ methods for connecting and disconnecting the client.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":329-364",
            "content": "            max_value = (1 << (8 * size)) - 1\n            value = max_value + value\n        return value\n    def __enter__(self):\n        \"\"\"Enables use as a context manager.\"\"\"\n        if not self.is_connected:\n            self.connect()\n        return self\n    def __exit__(self, *args):\n        \"\"\"Enables use as a context manager.\"\"\"\n        self.disconnect()\n    def __del__(self):\n        \"\"\"Automatically disconnect on destruction.\"\"\"\n        self.disconnect()\nclass DynamixelReader:\n    \"\"\"Reads data from Dynamixel motors.\n    This wraps a GroupBulkRead from the DynamixelSDK.\n    \"\"\"\n    def __init__(self, client: DynamixelClient, motor_ids: Sequence[int],\n                 address: int, size: int):\n        \"\"\"Initializes a new reader.\"\"\"\n        self.client = client\n        self.motor_ids = motor_ids\n        self.address = address\n        self.size = size\n        self._initialize_data()\n        self.operation = self.client.dxl.GroupBulkRead(client.port_handler,\n                                                       client.packet_handler)"
        },
        {
            "comment": "This code is part of a function that reads data from multiple motors. It iterates through motor IDs, adds parameters for each ID to a bulk read operation, and then attempts to execute the operation until it succeeds or retries run out. If the operation fails, it returns previously stored data instead. The code also checks if the received data is available before processing it.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":366-391",
            "content": "        for motor_id in motor_ids:\n            success = self.operation.addParam(motor_id, address, size)\n            if not success:\n                raise OSError(\n                    '[Motor ID: {}] Could not add parameter to bulk read.'\n                    .format(motor_id))\n    def read(self, retries: int = 1):\n        \"\"\"Reads data from the motors.\"\"\"\n        self.client.check_connected()\n        success = False\n        while not success and retries >= 0:\n            comm_result = self.operation.txRxPacket()\n            success = self.client.handle_packet_result(\n                comm_result, context='read')\n            retries -= 1\n        # If we failed, send a copy of the previous data.\n        if not success:\n            return self._get_data()\n        errored_ids = []\n        for i, motor_id in enumerate(self.motor_ids):\n            # Check if the data is available.\n            available = self.operation.isAvailable(motor_id, self.address,\n                                                   self.size)"
        },
        {
            "comment": "This code initializes and updates data for dynamixel motors, allowing the user to read position, velocity, and current values. The class DynamixelPosVelCurReader inherits from DynamixelReader, which provides methods to read bulk data from multiple motors in a single command. The code checks if the data is available for each motor ID and logs any unavailable data. It also initializes, updates, and returns data in a numpy array format.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":392-424",
            "content": "            if not available:\n                errored_ids.append(motor_id)\n                continue\n            self._update_data(i, motor_id)\n        if errored_ids:\n            logging.error('Bulk read data is unavailable for: %s',\n                          str(errored_ids))\n        return self._get_data()\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        self._data[index] = self.operation.getData(motor_id, self.address,\n                                                   self.size)\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._data.copy()\nclass DynamixelPosVelCurReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,"
        },
        {
            "comment": "The code defines a class for Dynamixel client with custom scales for position, velocity, and current data. It initializes cached data using numpy zeros and updates the data for a given motor ID. This class is part of the mobile-aloha project, likely used to communicate with Dynamixel motors and collect their position, velocity, and current information.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":425-449",
            "content": "                 vel_scale: float = 1.0,\n                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,\n            size=LEN_PRESENT_POS_VEL_CUR,\n        )\n        self.pos_scale = pos_scale\n        self.vel_scale = vel_scale\n        self.cur_scale = cur_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._pos_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n        self._vel_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n        self._cur_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        cur = self.operation.getData(motor_id, ADDR_PRESENT_CURRENT,\n                                     LEN_PRESENT_CURRENT)\n        vel = self.operation.getData(motor_id, ADDR_PRESENT_VELOCITY,\n                                     LEN_PRESENT_VELOCITY)\n        pos = self.operation.getData(motor_id, ADDR_PRESENT_POSITION,"
        },
        {
            "comment": "This code defines a class `DynamixelPosReader` that inherits from `DynamixelReader` and reads positions and velocities of dynamixel motors. It takes in a client object, motor IDs, and scaling factors for position, velocity, and current. The `__init__` function initializes the superclass with the address and size of data to read, which is LEN_PRESENT_POS_VEL_CUR in this case. The function also converts unsigned values to signed and scales them using the provided scaling factors before storing the data in corresponding lists for position, velocity, and current. The `_get_data` function returns copies of the stored data.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":450-478",
            "content": "                                     LEN_PRESENT_POSITION)\n        cur = unsigned_to_signed(cur, size=2)\n        vel = unsigned_to_signed(vel, size=4)\n        pos = unsigned_to_signed(pos, size=4)\n        self._pos_data[index] = float(pos) * self.pos_scale\n        self._vel_data[index] = float(vel) * self.vel_scale\n        self._cur_data[index] = float(cur) * self.cur_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return (self._pos_data.copy(), self._vel_data.copy(),\n                self._cur_data.copy())\nclass DynamixelPosReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,\n                 vel_scale: float = 1.0,\n                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,\n            size=LEN_PRESENT_POS_VEL_CUR,\n        )"
        },
        {
            "comment": "The code defines a class for reading Dynamixel motors' positions and velocities. It initializes data, updates data index for the given motor ID, and returns a copy of the data. The `DynamixelVelReader` class inherits from `DynamixelReader`, initializing superclass with motor IDs, scales, and address for ADDR_PRESENT_POS_VEL_CUR.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":479-508",
            "content": "        self.pos_scale = pos_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._pos_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        pos = self.operation.getData(motor_id, ADDR_PRESENT_POSITION,\n                                     LEN_PRESENT_POSITION)\n        pos = unsigned_to_signed(pos, size=4)\n        self._pos_data[index] = float(pos) * self.pos_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._pos_data.copy()\nclass DynamixelVelReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,\n                 vel_scale: float = 1.0,\n                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,"
        },
        {
            "comment": "The provided code contains a class named `DynamixelClient` that initializes cached data and provides methods to update and retrieve data related to motor positions and velocities. The `_initialize_data` method initializes the cached velocity data as zeroes, while the `_update_data` method updates the data for the given motor ID. The `_get_data` method returns a copy of the data. Additionally, there is another class named `DynamixelCurReader`, which inherits from `DynamixelReader` and reads positions and velocities with scaling factors for position and velocity data.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":509-537",
            "content": "            size=LEN_PRESENT_POS_VEL_CUR,\n        )\n        self.pos_scale = pos_scale\n        self.vel_scale = vel_scale\n        self.cur_scale = cur_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._vel_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        vel = self.operation.getData(motor_id, ADDR_PRESENT_VELOCITY,\n                                     LEN_PRESENT_VELOCITY)\n        vel = unsigned_to_signed(vel, size=4)\n        self._vel_data[index] = float(vel) * self.vel_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._vel_data.copy()\nclass DynamixelCurReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,\n                 vel_scale: float = 1.0,"
        },
        {
            "comment": "The code defines a Dynamixel client class that initializes cached data, updates current data for specific motor IDs, and returns the data when requested. It uses numpy to create zero-initialized arrays and handles unsigned to signed conversions. A global cleanup function is also registered.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":538-570",
            "content": "                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,\n            size=LEN_PRESENT_POS_VEL_CUR,\n        )\n        self.cur_scale = cur_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._cur_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        cur = self.operation.getData(motor_id, ADDR_PRESENT_CURRENT,\n                                     LEN_PRESENT_CURRENT)\n        cur = unsigned_to_signed(cur, size=2)\n        self._cur_data[index] = float(cur) * self.cur_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._cur_data.copy()\n# Register global cleanup function.\natexit.register(dynamixel_cleanup_handler)\nif __name__ == '__main__':\n    import argparse\n    import itertools\n    parser = argparse.ArgumentParser()"
        },
        {
            "comment": "The code defines command line arguments for motor IDs, device to connect, and baudrate. It then parses the arguments, converts the motor IDs into a list, creates two waypoints using NumPy arrays, and establishes a connection with the Dynamixel client. The script continuously updates the motors' positions based on the current step in a loop, printing the new position and writing it to the client. It also measures the time taken for reading positions, velocities, and current values from the client.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":571-597",
            "content": "    parser.add_argument(\n        '-m',\n        '--motors',\n        required=True,\n        help='Comma-separated list of motor IDs.')\n    parser.add_argument(\n        '-d',\n        '--device',\n        default='/dev/ttyUSB0',\n        help='The Dynamixel device to connect to.')\n    parser.add_argument(\n        '-b', '--baud', default=1000000, help='The baudrate to connect with.')\n    parsed_args = parser.parse_args()\n    motors = [int(motor) for motor in parsed_args.motors.split(',')]\n    way_points = [np.zeros(len(motors)), np.full(len(motors), np.pi)]\n    with DynamixelClient(motors, parsed_args.device,\n                         parsed_args.baud) as dxl_client:\n        for step in itertools.count():\n            if step > 0 and step % 50 == 0:\n                way_point = way_points[(step // 100) % len(way_points)]\n                print('Writing: {}'.format(way_point.tolist()))\n                dxl_client.write_desired_pos(motors, way_point)\n            read_start = time.time()\n            pos_now, vel_now, cur_now = dxl_client.read_pos_vel_cur()"
        },
        {
            "comment": "This code block prints the frequency, positions, velocities, and currents of a dynamixel robot every 5 steps. It updates the time elapsed since the last read operation and uses it to calculate the frequency. The data is formatted using string formatting before being printed.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/dynamixel_client.py\":598-603",
            "content": "            if step % 5 == 0:\n                print('[{}] Frequency: {:.2f} Hz'.format(\n                    step, 1.0 / (time.time() - read_start)))\n                print('> Pos: {}'.format(pos_now.tolist()))\n                print('> Vel: {}'.format(vel_now.tolist()))\n                print('> Cur: {}'.format(cur_now.tolist()))"
        }
    ]
}