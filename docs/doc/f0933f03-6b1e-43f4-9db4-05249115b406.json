{
    "summary": "The code initializes an ImageRecorder class for acquiring images and frequencies, sets up camera variables and subscribers, and includes a Recorder class with optional debug mode. It also initializes variables and callback functions for controlling a robot's arm and gripper with smooth movement and calibration functions.",
    "details": [
        {
            "comment": "The code is initializing an \"ImageRecorder\" class that utilizes various imports, such as numpy and rospy. It also sets up camera names and related variables for different cameras. The class initializes the camera image, time stamp, and subscribes to image topics with callback functions depending on the camera name.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":0-26",
            "content": "import numpy as np\nimport time\nfrom constants import DT\nfrom interbotix_xs_msgs.msg import JointSingleCommand\nimport IPython\ne = IPython.embed\nclass ImageRecorder:\n    def __init__(self, init_node=True, is_debug=False):\n        from collections import deque\n        import rospy\n        from cv_bridge import CvBridge\n        from sensor_msgs.msg import Image\n        self.is_debug = is_debug\n        self.bridge = CvBridge()\n        self.camera_names = ['cam_high', 'cam_left_wrist', 'cam_right_wrist'] #['cam_high', 'cam_low', 'cam_left_wrist', 'cam_right_wrist']\n        if init_node:\n            rospy.init_node('image_recorder', anonymous=True)\n        for cam_name in self.camera_names:\n            setattr(self, f'{cam_name}_image', None)\n            setattr(self, f'{cam_name}_secs', None)\n            setattr(self, f'{cam_name}_nsecs', None)\n            if cam_name == 'cam_high':\n                callback_func = self.image_cb_cam_high\n            elif cam_name == 'cam_low':\n                callback_func = self.image_cb_cam_low"
        },
        {
            "comment": "The code defines a subscriber function for camera image data from different cameras (cam_left_wrist, cam_right_wrist, and cam_high) and assigns specific callback functions for each camera. The callback functions will process the received images and timestamps if debug mode is enabled. Additionally, it includes a time.sleep(0.5) function to wait before processing data.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":27-47",
            "content": "            elif cam_name == 'cam_left_wrist':\n                callback_func = self.image_cb_cam_left_wrist\n            elif cam_name == 'cam_right_wrist':\n                callback_func = self.image_cb_cam_right_wrist\n            else:\n                raise NotImplementedError\n            rospy.Subscriber(f\"/usb_{cam_name}/image_raw\", Image, callback_func)\n            if self.is_debug:\n                setattr(self, f'{cam_name}_timestamps', deque(maxlen=50))\n        time.sleep(0.5)\n    def image_cb(self, cam_name, data):\n        setattr(self, f'{cam_name}_image', self.bridge.imgmsg_to_cv2(data, desired_encoding='passthrough'))\n        setattr(self, f'{cam_name}_secs', data.header.stamp.secs)\n        setattr(self, f'{cam_name}_nsecs', data.header.stamp.nsecs)\n        # cv2.imwrite('/home/tonyzhao/Desktop/sample.jpg', cv_image)\n        if self.is_debug:\n            getattr(self, f'{cam_name}_timestamps').append(data.header.stamp.secs + data.header.stamp.secs * 1e-9)\n    def image_cb_cam_high(self, data):\n        cam_name = 'cam_high'"
        },
        {
            "comment": "This code defines a class with methods for getting images from different camera sources and calculating image frequencies. It also includes a helper function for calculating the average time difference between timestamps. The Recorder class is initialized with a side parameter, optionally initializes a node, and has an is_debug flag.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":48-80",
            "content": "        return self.image_cb(cam_name, data)\n    def image_cb_cam_low(self, data):\n        cam_name = 'cam_low'\n        return self.image_cb(cam_name, data)\n    def image_cb_cam_left_wrist(self, data):\n        cam_name = 'cam_left_wrist'\n        return self.image_cb(cam_name, data)\n    def image_cb_cam_right_wrist(self, data):\n        cam_name = 'cam_right_wrist'\n        return self.image_cb(cam_name, data)\n    def get_images(self):\n        image_dict = dict()\n        for cam_name in self.camera_names:\n            image_dict[cam_name] = getattr(self, f'{cam_name}_image')\n        return image_dict\n    def print_diagnostics(self):\n        def dt_helper(l):\n            l = np.array(l)\n            diff = l[1:] - l[:-1]\n            return np.mean(diff)\n        for cam_name in self.camera_names:\n            image_freq = 1 / dt_helper(getattr(self, f'{cam_name}_timestamps'))\n            print(f'{cam_name} {image_freq=:.2f}')\n        print()\nclass Recorder:\n    def __init__(self, side, init_node=True, is_debug=False):\n        from collections import deque"
        },
        {
            "comment": "This code initializes necessary variables and sets up subscribers for joint states, arm commands, and gripper commands. It also optionally initializes debug-related deques and waits 0.1 seconds before processing joint state data.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":81-105",
            "content": "        import rospy\n        from sensor_msgs.msg import JointState\n        from interbotix_xs_msgs.msg import JointGroupCommand, JointSingleCommand\n        self.secs = None\n        self.nsecs = None\n        self.qpos = None\n        self.effort = None\n        self.arm_command = None\n        self.gripper_command = None\n        self.is_debug = is_debug\n        if init_node:\n            rospy.init_node('recorder', anonymous=True)\n        rospy.Subscriber(f\"/puppet_{side}/joint_states\", JointState, self.puppet_state_cb)\n        rospy.Subscriber(f\"/puppet_{side}/commands/joint_group\", JointGroupCommand, self.puppet_arm_commands_cb)\n        rospy.Subscriber(f\"/puppet_{side}/commands/joint_single\", JointSingleCommand, self.puppet_gripper_commands_cb)\n        if self.is_debug:\n            self.joint_timestamps = deque(maxlen=50)\n            self.arm_command_timestamps = deque(maxlen=50)\n            self.gripper_command_timestamps = deque(maxlen=50)\n        time.sleep(0.1)\n    def puppet_state_cb(self, data):\n        self.qpos = data.position"
        },
        {
            "comment": "This code initializes variables for joint velocity, effort, and data, and defines callback functions for arm and gripper commands. It also calculates frequencies of the joint timestamps, arm command timestamps, and gripper command timestamps for diagnostics printing. The get_arm_joint_positions function retrieves the positions of the first six joints of the robot's arm.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":106-135",
            "content": "        self.qvel = data.velocity\n        self.effort = data.effort\n        self.data = data\n        if self.is_debug:\n            self.joint_timestamps.append(time.time())\n    def puppet_arm_commands_cb(self, data):\n        self.arm_command = data.cmd\n        if self.is_debug:\n            self.arm_command_timestamps.append(time.time())\n    def puppet_gripper_commands_cb(self, data):\n        self.gripper_command = data.cmd\n        if self.is_debug:\n            self.gripper_command_timestamps.append(time.time())\n    def print_diagnostics(self):\n        def dt_helper(l):\n            l = np.array(l)\n            diff = l[1:] - l[:-1]\n            return np.mean(diff)\n        joint_freq = 1 / dt_helper(self.joint_timestamps)\n        arm_command_freq = 1 / dt_helper(self.arm_command_timestamps)\n        gripper_command_freq = 1 / dt_helper(self.gripper_command_timestamps)\n        print(f'{joint_freq=:.2f}\\n{arm_command_freq=:.2f}\\n{gripper_command_freq=:.2f}\\n')\ndef get_arm_joint_positions(bot):\n    return bot.arm.core.joint_states.position[:6]"
        },
        {
            "comment": "The code includes functions for controlling the robot's arms and grippers. The 'get_arm_gripper_positions' function retrieves the current position of the robot's gripper, while 'move_arms' sets the desired positions for all robots in the list over a specified duration. Similarly, 'move_grippers' sets the gripper positions for each robot over time. Both functions use linear interpolation to smoothly move the robot's joints.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":137-156",
            "content": "def get_arm_gripper_positions(bot):\n    joint_position = bot.gripper.core.joint_states.position[6]\n    return joint_position\ndef move_arms(bot_list, target_pose_list, move_time=1):\n    num_steps = int(move_time / DT)\n    curr_pose_list = [get_arm_joint_positions(bot) for bot in bot_list]\n    traj_list = [np.linspace(curr_pose, target_pose, num_steps) for curr_pose, target_pose in zip(curr_pose_list, target_pose_list)]\n    for t in range(num_steps):\n        for bot_id, bot in enumerate(bot_list):\n            bot.arm.set_joint_positions(traj_list[bot_id][t], blocking=False)\n        time.sleep(DT)\ndef move_grippers(bot_list, target_pose_list, move_time):\n    gripper_command = JointSingleCommand(name=\"gripper\")\n    num_steps = int(move_time / DT)\n    curr_pose_list = [get_arm_gripper_positions(bot) for bot in bot_list]\n    traj_list = [np.linspace(curr_pose, target_pose, num_steps) for curr_pose, target_pose in zip(curr_pose_list, target_pose_list)]\n    for t in range(num_steps):\n        for bot_id, bot in enumerate(bot_list):"
        },
        {
            "comment": "This code contains functions for setting up and controlling a robot's movements, gripper, and motor settings. The `setup_puppet_bot` function initializes the puppet bot's motors, while `setup_master_bot` configures the master bot's arm movement. The `set_standard_pid_gains` and `set_low_pid_gains` functions adjust the robot's PID gains for position control of its arm. The `torque_on` and `torque_off` functions enable or disable torque for the group arm motors, respectively.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":157-181",
            "content": "            gripper_command.cmd = traj_list[bot_id][t]\n            bot.gripper.core.pub_single.publish(gripper_command)\n        time.sleep(DT)\ndef setup_puppet_bot(bot):\n    bot.dxl.robot_reboot_motors(\"single\", \"gripper\", True)\n    bot.dxl.robot_set_operating_modes(\"group\", \"arm\", \"position\")\n    bot.dxl.robot_set_operating_modes(\"single\", \"gripper\", \"current_based_position\")\n    torque_on(bot)\ndef setup_master_bot(bot):\n    bot.dxl.robot_set_operating_modes(\"group\", \"arm\", \"pwm\")\n    bot.dxl.robot_set_operating_modes(\"single\", \"gripper\", \"current_based_position\")\n    torque_off(bot)\ndef set_standard_pid_gains(bot):\n    bot.dxl.robot_set_motor_registers(\"group\", \"arm\", 'Position_P_Gain', 800)\n    bot.dxl.robot_set_motor_registers(\"group\", \"arm\", 'Position_I_Gain', 0)\ndef set_low_pid_gains(bot):\n    bot.dxl.robot_set_motor_registers(\"group\", \"arm\", 'Position_P_Gain', 100)\n    bot.dxl.robot_set_motor_registers(\"group\", \"arm\", 'Position_I_Gain', 0)\ndef torque_off(bot):\n    bot.dxl.robot_torque_enable(\"group\", \"arm\", False)"
        },
        {
            "comment": "The code contains functions for robot control: \"robot_torque_enable\" enables torque control for specific groups or individual joints, \"calibrate_linear_vel\" adjusts the linear velocity of the base action, \"smooth_base_action\" uses convolution to smooth the base action, and \"postprocess_base_action\" scales down the angular velocity.",
            "location": "\"/media/root/Prima/works/mobile-aloha/docs/src/aloha_scripts/robot_utils.py\":182-205",
            "content": "    bot.dxl.robot_torque_enable(\"single\", \"gripper\", False)\ndef torque_on(bot):\n    bot.dxl.robot_torque_enable(\"group\", \"arm\", True)\n    bot.dxl.robot_torque_enable(\"single\", \"gripper\", True)\ndef calibrate_linear_vel(base_action, c=None):\n    if c is None:\n        c = 0.\n    v = base_action[..., 0]\n    w = base_action[..., 1]\n    base_action = base_action.copy()\n    base_action[..., 0] = v - c * w\n    return base_action\ndef smooth_base_action(base_action):\n    return np.stack([\n        np.convolve(base_action[:, i], np.ones(5)/5, mode='same') for i in range(base_action.shape[1])\n    ], axis=-1).astype(np.float32)\ndef postprocess_base_action(base_action):\n    linear_vel, angular_vel = base_action\n    angular_vel *= 0.9\n    return np.array([linear_vel, angular_vel])"
        }
    ]
}